![](../doc/pic/preview_5.png)

---

## Общее описание

**Курс состоит из 3 практических занятий**. Каждое занятие содержит ссылки на теорию, рекомендуемую к освоению перед выполнением. Хоть каждое занятие и является самостоятельной единицой (не зависит от других), рекомендуется выполнять их по порядку.


## Занятия

---

- [Практическое занятие 00: Тест "Hello world!"](./00_basic_hex/)
  
  **Краткое описание:**

  Данное занятие воспроизводит маршрут подхода к верификации процессорных ядер ["Hello world"](../theory/03_func.md#hello-world) на примере RISC-V ядра с открытым исходным кодом [MIRISCV](https://github.com/riscv-tests-intro/MIRISCV/tree/b510b308addc4a7271e36f2a348bd18bf24c1d77).
  
  В ходе занятия анализируются функциональные особенности тестируемого ядра, создается верификационное окружение при помощи языка [SystemVerilog](https://en.wikipedia.org/wiki/SystemVerilog). Пишется простейшая тестовая программа на языке ассемблера RISC-V[^1]. Программа загружается в модель памяти, взаимодействие ядра с которой симулируется при помощи [Verilator](https://github.com/verilator/verilator/tree/522bead374d6b7b2adb316304126e5361b18bcf1). Анализируется поведение процессорного ядра, делается вывод о корректности его работы

---

- [Практическое занятие 01: Тестирование с самопроверкой](./01_riscv_tests/)
  
  **Краткое описание:**

  Данное занятие воспроизводит маршрут подхода к верификации процессорных ядер [тестирование с самопроверкой](../theory/03_func.md#тестирование-с-самопроверкой) на примере RISC-V ядра с открытым исходным кодом [MIRISCV](https://github.com/riscv-tests-intro/MIRISCV/tree/b510b308addc4a7271e36f2a348bd18bf24c1d77).

  В ходе занятия разбирается один из самых популярных наборов тестовых сценариев [riscv-tests](https://github.com/riscv-software-src/riscv-tests/tree/408e461da11e0b298c4b69e587729532787212f5). Анализируются  функциональные особенности тестируемого ядра, сценарии [riscv-tests](https://github.com/riscv-software-src/riscv-tests/tree/408e461da11e0b298c4b69e587729532787212f5) модифицируются с целью их поддержки, создается верификационное окружение при помощи языка [SystemVerilog](https://en.wikipedia.org/wiki/SystemVerilog). Тестовые программы компилируются, экспортируются и загружаются в модель памяти. Взаимодействие ядра с памятью симулируется при помощи [Verilator](https://github.com/verilator/verilator/tree/522bead374d6b7b2adb316304126e5361b18bcf1). Анализируется поведение процессорного ядра, делается вывод о корректности его работы, автоматизируется процесс проверки каждой инструкции расширений RV32I и RV32M[^2].

---

- [Практическое занятие 02: сравнение с эталонной моделью](./02_aapg/)

  **Краткое описание:**

  Данное занятие воспроизводит маршрут подхода к верификации процессорных ядер [сравнение с эталонной моделью](../theory/04_rgen.md) на примере RISC-V ядра с открытым исходным кодом [MIRISCV](https://github.com/riscv-tests-intro/MIRISCV/tree/b510b308addc4a7271e36f2a348bd18bf24c1d77).

  В ходе занятия при помощи генератора случайных инструкций [AAPG](https://gitlab.com/shaktiproject/tools/aapg/-/tree/7ce4a9073a040bbc784edfd1c8a7b21f269f7766) создается тестовая программа. В процессе генератор модифицируется и конфигурируется с учетом особенностей тестируемого ядра. Создается верификационное окружение с использованием объектно-ориентированного подхода. Тестовая программа экспортируется и загружается в модель памяти окружения. Взаимодействие ядра с памятью симулируется при помощи [Verilator](https://github.com/verilator/verilator/tree/522bead374d6b7b2adb316304126e5361b18bcf1). Ход выполнения программы процессором логируется при помощи интерфейса [RVFI](../theory/04_rgen.md#интерфейс-rvfi) и [несинтезируемого модуля трассировки](../theory/04_rgen.md#описание-подхода-часть-1).
  
  Запуск сгенерированной тестовой программы также воспроизводится на эталонной модели [Spike](https://github.com/riscv-software-src/riscv-isa-sim/tree/887d02e42124ddc86476dfdf4aad4be8ba7f0aef), написанной на языке C. Эталонная программа формирует лог-файл, который сравнивается с лог-файлом тестируемого ядра.

---

- [Практическое занятие 03: Синхронное сравнение с эталонной моделью](./03_hammer/)

Данное занятие воспроизводит маршрут подхода к верификации процессорных ядер [синхронное сравнение с эталонной моделью](../theory/05_advanced.md#синхронное-сравнение) на примере RISC-V ядра с открытым исходным кодом [MIRISCV](https://github.com/riscv-tests-intro/MIRISCV/tree/b510b308addc4a7271e36f2a348bd18bf24c1d77).

В ходе занятия верификациооное окружение предыдущего занятия модифицируется с целью реализации сравнения поведения ядра с эталонной моделью [Spike](https://github.com/riscv-software-src/riscv-isa-sim/tree/887d02e42124ddc86476dfdf4aad4be8ba7f0aef) непосредственно в ходе RTL-симуляции после выполнения каждой новой инструкции. Для взаимодействия со Spike используется открытая библиотека [Hammer](https://github.com/rivosinc/hammer/tree/6d9fac96407149a1a533cdd3f63f6bbd96614ffa), разработанная компанией [Rivos Inc.](https://www.rivosinc.com/). Вызов методов библиотеки реализуется при помощи DPI-C методов[^3]. Сравнение производится в специализированном классе проверки, в который строен класс, в ходе симуляции опционально формирующий подробный лог-файл сравнения.

Для создания случайной тестовой программы используется генератор [AAPG](https://gitlab.com/shaktiproject/tools/aapg/-/tree/7ce4a9073a040bbc784edfd1c8a7b21f269f7766), RTL-симуляция производится при помощи [Verilator](https://github.com/verilator/verilator/tree/522bead374d6b7b2adb316304126e5361b18bcf1).

---

[^1]: Язык ассемблера - язык программирования низкого уровня со строгим соответствием между командами языка и инструкциями машинного кода архитектуры. Исчерпывающий документ по ассемблеру RISC-V доступен по [ссылке](https://github.com/riscv-non-isa/riscv-asm-manual/blob/main/riscv-asm.md). Статья для начинающих по ассемблеру RISC-V доступна по [ссылке](https://habr.com/en/articles/558706/).

[^2]: Расширения определены в спецификации RISC-V (ссылку на нее можно найти в разделе [Минимальные требования к знаниям](../README.md#минимальные-требования-к-знаниям) в корне репозитория).

[^3]: SystemVerilog DPI-C – механизм, позволяющий осуществлять вызов C/C++ кода непосредственно из SystemVerilog (и SystemVerilog из C/C++ кода) в ходе симуляции. Хорошие открытые ознакомительные материалы о SystemVerilog DPI-C: [SystemVerilog DPI Tutorial](https://www.doulos.com/knowhow/systemverilog/systemverilog-tutorials/systemverilog-dpi-tutorial/) и [How to Call C-functions from SystemVerilog Using DPI-C](https://www.consulting.amiq.com/2019/01/30/how-to-call-c-functions-from-systemverilog-using-dpi-c/).
