# Тема 01: Функциональная верификация процессорных ядер

- [Тема 01: Функциональная верификация процессорных ядер](#тема-01-функциональная-верификация-процессорных-ядер)
  - [Рекомендуемый материал](#рекомендуемый-материал)
  - [Краткое содержание](#краткое-содержание)
  - [Верификация цифровых устройств](#верификация-цифровых-устройств)
  - [Маршрут проектирования цифровых устройств](#маршрут-проектирования-цифровых-устройств)
    - [Этап спецификации](#этап-спецификации)
    - [Этап разработки архитектуры](#этап-разработки-архитектуры)
    - [Этапы RTL и верификации RTL](#этапы-rtl-и-верификации-rtl)
    - [Этапы синтеза и верификации результатов синтеза](#этапы-синтеза-и-верификации-результатов-синтеза)
    - [Этапы физического дизайна\[^5\] и верификации физического дизайна](#этапы-физического-дизайна5-и-верификации-физического-дизайна)
  - [Функциональная верификация цифровых устройств](#функциональная-верификация-цифровых-устройств)
  - [Введение в верификацию процессорных ядер](#введение-в-верификацию-процессорных-ядер)
    - [Обобщенная схема верификации процессорного ядра](#обобщенная-схема-верификации-процессорного-ядра)
    - [Архитектура и микроархитектура процессорного ядра](#архитектура-и-микроархитектура-процессорного-ядра)
    - [Спецификация процессорного ядра](#спецификация-процессорного-ядра)
  - [Особенности верификации процессорных ядер](#особенности-верификации-процессорных-ядер)
    - [Архитектурные особенности](#архитектурные-особенности)
    - [Микроархитектурные особенности](#микроархитектурные-особенности)
  - [Особенности верификации RISC-V ядер](#особенности-верификации-risc-v-ядер)
    - [Как RISC-V упрощает работу верификатора](#как-risc-v-упрощает-работу-верификатора)
    - [Как RISC-V усложняет работу верификатора](#как-risc-v-усложняет-работу-верификатора)
    - [Так упрощает или усложняет?](#так-упрощает-или-усложняет)
  - [To be continued...](#to-be-continued)

## Рекомендуемый материал

- [Тема 00: Вводная](./00_intro.md)

## Краткое содержание

Данное занятие содержит в себе теорию об основах верификации цифровых устройств, а в частности функциональной верификации. Вводятся понятия архитектуры и микроархитектуры. Подробно разбирается их связь с фукнциональной верификацией процессорных ядер.

В завершение занятия разбирается влияние особенностей архитектуры набора команд RISC-V на процесс верификации ядер, спроектированных на ее основе.

## Верификация цифровых устройств

В общем случае, **верификация цифрового устройства** – это процесс обоснованного доказательства его корректной работы в рамках представленной на него спецификации. Но что же такое спецификация?

**Спецификация** – это набор задокументированных требований. Она определяет характеристики устройства. Например, для устройства, вычисляющего быстрое преобразование Фурье[^1], спецификация может определять как функциональные особенности (разрядность данных, количество точек, основание и т.д.), так и требования к производительности и энергопотреблению (частота работы схемы, потребляемая мощность). Чтобы не быть голословным, автор прикрепляет [ссылку на статью про сравнение различных реализаций быстрого преобразования Фурье  в интегральных схемах](https://essay.utwente.nl/72179/1/FFT_Comparison_Simon_Dirlik.pdf).

## Маршрут проектирования цифровых устройств

На изображнении ниже представлен обобщенный маршрут проектирования цифровых устройств.

![](../doc/pic/verif_flow_4.png)

### Этап спецификации

На **этапе спецификации** формируется документация, описывающая функционал устройства, его временные и мощностные характеристики (например, максимально возможная тактовая частота, при которой поведение устройства эквивалентно описано в спецификации, а также пиковая потребляемая мощность). В создании спецификации участвует как заказчик, так и исполнитель.

### Этап разработки архитектуры

На **этапе разработки архитектуры** создается внутренняя документация исполнителя, которая описывает устройство на уровне совокупности блоков, каждый из которых выполняет определенный ему функционал. После описания совокупности блоков, каждый описывается отдельно. Причем блок так же может является совокупностью блоков. Таких уровней вложенности может быть несколько, их количество определяется командной проектировщиков[^2]. Каждое описание по своей сути является является спецификацией, но более низкого уровня, и является интеллектуальной собственностью исполнителя, то есть, в большинстве случаев, заказчик имеет очень ограниченный доступ к этим документам.

### Этапы RTL и верификации RTL

На этапах **RTL** и **верификации RTL** (выполняемых в идеальном случае параллельно) набор спецификаций преобразуется при помощи когнитивных способностей команды проектировщиков в HDL-описание[^3] на уровне регистровых передач (Register Transfer Level, RTL)[^4], которое проверяется на соответствие спецификации командой верификации. О том, как это делается, поговорим чуть позже.

### Этапы синтеза и верификации результатов синтеза

На этапе **синтеза** RTL уровень HDL-описания транслируется при помощи специализированного ПО в более низкий уровень представления - [в виде универсальных ячеек (gate-level)](https://www.youtube.com/watch?v=UrMumwROPK8). Это все еще HDL описание, правда уже не универсальное, а специфичное для той фабрики, на которой будет изготавливаться устройство. В большинстве случаев синтез состоит из нескольких этапов, в ходе каждого из которых формируется новое, притерпевшее некоторые изменения, gate-level описание, а также сопровождающие эти описания файлы (например, [файлы временных задержек](https://docstech.ru/sdf-verilog/)). На этапе **верификации результатов синтеза** происходит проверка соответствия gate-level описаний между собой и их соответствие спецификации (в том числе временным и мощностным характеристикам).

Помимо gate-level представлений дизайна, результатом синтеза является [файл формата GDSII](https://en.wikipedia.org/wiki/GDSII), который будет использован на фабрике для создания реальной физической микросхемы.

### Этапы физического дизайна[^5] и верификации физического дизайна

После получения **реального физического дизайна** с фабрики, наступает этап **его верификации**. Данный этап включает в себя множество проверок. Начиная от проверки отсутствия коротких замыканий, до запуска программного обеспечения (в случае, если устройство содержит в себе блок для его запуска) и замеров реального энергопотребления в различных условиях.

## Функциональная верификация цифровых устройств

**Обратите внимание**, что далее под термином "верификация" будет подразумеваться верификация функциональных особенностей устройства.

В качетсве примера, в ходе верификации функциональных особенностей модуля быстрого преобразования Фурье подтверждается правильность вычисления преобразования в рамках определенной для него разрядности входных и выходных данных, количества точек и т.д. Временные и мощностные характеристики в ходе функциональной верификации не проверяются.

При этом подразумевается, что рассматривается только [этап верификации RTL](#этапы-rtl-и-верификации-rtl). Часть процессов [этапа верификации результатов синтеза](#этапы-синтеза-и-верификации-результатов-синтеза) также можно рассматривать как функциональную верификацию, однако со своими особенностями, которые выходят за рамки данного курса. Это касается и [этапа верификации физического дизайна](#этапы-физического-дизайна5-и-верификации-физического-дизайна).

Максимально упрощенно процесс функциональной верификации представлен на изображении ниже.

<p align="center">
  <img src="../doc/pic/verif_flow_5.png" width=500></img>
</p>

Возможно, что пока для читателя тестирование представляется некоторым магическим процессом, на основании результатов которого делается вывод о корретности работы устройства. В ближайших разделах автрр постарается прояснить ситуацию.

## Введение в верификацию процессорных ядер

### Обобщенная схема верификации процессорного ядра

**Обратим внимание**, что частным случаем цифрового устройства является процессорное ядро. Таким образом, **верификация процессорного ядра** – это процесс обоснованного доказательства корректной его работы в рамках представленной на него спецификации.

Важным замечанием здесь является то, что спецификация определяет не только функционал устройства (далее в качестве синонима слова "устройство" может использоваться слово "дизайн"), но и прямым образом влияет на структуру и особенности верификационного окружения.

**Проектирование дизайна и верификационного окружения – процессы достаточно независимые**, опирающиеся на спецификацию. Можно сказать, что дизайнер и верификатор описывают каждый свое видение представленных требований. Далее эти описания сравниваются.

![](../doc/pic/verif_flow_13.gif)

Открытым остается вопрос: **чем по своей сути является спецификация на процессорное ядро?** Для ответа необходимо определить то, что свойственно каждому процессору.

### Архитектура и микроархитектура процессорного ядра

Современному процессору свойственны:
- архитектура;
- микроархитектура.

В текущих реалиях индустрии термин **"архитектура" синонимичен термину "архитектура набора команд (АНК)"**, которая определяет набор инструкций для исполнения, адресное пространство, количество и разрядность регистров общего и специального назначения, модель памяти, особенности виртуализации адресного пространства и т.д.

**Микроархитектура – это аппаратная реализация АНК.** Изначально она определяется внутренней документацией конкретной компании, в которой разрабатывается ядро. На основе этой документации уже создается HDL-описание, которое отправляется на дальнейшие этапы проектирования. 

**Если архитектура отвечает на вопрос "что?", то микроархитектура отвечает на вопрос "как?".** Одна и та же АНК (или ее часть) может быть реализована посредством аппаратно абсолютно различающихся между собой ядер.

Один процессор может быть конвейерным, второй – однотактным. В различных конвейерах могут быть применены различные алгоритмы разрешения конфликтов. Одно ядро может позиционироваться, как высокопроизводительное, и из-за микроархитектурных особенностей потреблять больше энергии, чем второе ядро, основным преимуществом которого является низкая потребляемая мощность.

### Спецификация процессорного ядра

Архитектура набора команд оказывает непосредственное влияние на микроархитектуру, а микроархитектура определяет функциональные особенности ядра. Таким образом, **АНК и микроархитектура определяют спецификацию процессора.** Стоит заметить, что процесс интеграции пользовательского функционала также определяется в рамках АНК.

![](../doc/pic/verif_flow_1.png)

В общем виде верификация процессора представляет собой практически параллельный c реализацией дизайна процесс проектирования верификационного окружения на основе АНК и микроархитектуры с последующей проверкой.

По сути, на этапе проверки происходит сравнение интерпретации спецификации дизайнером и верификатором. **Здесь важен именно независимый взгляд с разных сторон**: со стороны синтезируемого HDL-описания и со стороны высокоуровневого HDL-описания или описания при помощи других средств программирования.

## Особенности верификации процессорных ядер

Как было сказано выше, спецификацию на процессор определяют АНК и микроархитектура. Каждая их этих составляющих вносит определенные сложности для верификатора.

### Архитектурные особенности

**АНК в большинстве случаев является документом или набором документов сравнительно большого объема.** В качестве примера, последняя на момент написания текста часть спецификации RISC-V [The RISC-V Instruction Set Manual Volume I. Unprivileged Architecture. Version 20240411](https://drive.google.com/file/d/1uviu1nH-tScFfgrovvFCrj7Omv8tFtkp/view) занимает 670 страниц. Обратите внимания, что это лишь ее часть. Прочтение и анализ могут занять недели и даже месяцы в зависимости от части архитектуры, которую планируется реализовать[^6].

В процессе проверки необходимо подтвердить корректность выполнения каждой инструкции, корректность доступа ко всем реализованным регистрам общего и специального назначения. Для генерации тестовых программ важно соблюдать соглашение о вызовах[^7], которое тоже является частью АНК. Особое место отводится проверке обработки исключений, ведь обновление состояния ядра в этом случае также описано в архитектуре набора команд.

### Микроархитектурные особенности

**Микроархитектура также влияет на процесс создания верификационного окружения.** Здесь производятся специфичные проверки на определенные последовательности инструкций, приводящие, например, к конфликтам в конвейере. Особое место отводится проверке асинхронных событий (прерываний), очередность и условия обработки которых определяются микроархитектурой. Свою роль также играет, как правило, пользовательский интерфейс памяти со своим протоколом обмена.

Для процессоров с поддержкой режима отладки важны проверки обновления внутреннего состояния при переходе в этот режим. Специфичное внутреннее состояние определяется АНК. Однако внешние воздействия для входа в режим отладки могут варьироваться в зависимости от конкретной микроархитектурной реализации[^8].

## Особенности верификации RISC-V ядер

В прошлом разделе были определены общие особенности верификации процессорных ядер. Однако **стоит заметить**, что у каждой АНК есть свои отличительные черты, которые могут как вносить дополнительные сложности, так и облегчать задачу тестирования. Рассмотрим архитектуру RISC-V.

### Как RISC-V упрощает работу верификатора

**Упрощает работу верификатору открытость данной архитектуры**. Уже сейчас в открытом доступе существует большое количество решений для верификации RISC-V ядер, начиная от готовых верификационных окружений, например:

- [Верификационное окружение ядра Ibex](https://github.com/lowRISC/ibex/tree/master/dv);
- [Верификационные окружения ядер OpenHW Group](https://github.com/openhwgroup/core-v-verif).

и наборов тестовых сценариев, например:

- [Набор тестовых сценариев riscv-tests](https://github.com/riscv-software-src/riscv-tests);
- [Набор тестовых сценариев riscv-arch-test](https://github.com/riscv-non-isa/riscv-arch-test).

и заканчивая генераторами случайных инструкций, например:

- [Генератор случайных RISC-V инструкций RISCV-DV](https://github.com/chipsalliance/riscv-dv);
- [Генератор случайных RISC-V инструкций MicroTESK](https://forge.ispras.ru/projects/microtesk-riscv);
- [Генератор случайных RISC-V инструкций AAPG](https://gitlab.com/shaktiproject/tools/aapg).

Также в открытом доступе присутствуют программные модели процессоров, например:

- [Программная С модель RISC-V Spike](https://github.com/riscv-software-src/riscv-isa-sim);
- [Программная C++ модель RISC-V VeeR-ISS](https://github.com/chipsalliance/VeeR-ISS);
- [Программная Rust модель RISC-V Rust RISC-V Simulator](https://github.com/GregAC/rrs);

**Инженер может повторно использовать открытые решения в своих разработках**, перенимать опыт и делиться своим собственным. Данные факторы ускоряют и упрощают процесс верификации.

### Как RISC-V усложняет работу верификатора

**Усложняет работу верификатора модульность АНК.** RISC-V содержит базовое расширение RV32I, состоящее из 49 инструкций. При этом оно дополнено еще несколькими десятками опциональных расширений для реализации умножения, деления, операций с плавающей точкой, криптографии и т.п.

Опциональные расширения содержат сотни инструкций, каждая из которых может иметь свою реализацию в аппаратуре (например, деление в зависимости от алгоритма может занимать различное количество тактов). 

**Таким образом, каждое ядро имеет свою уникальную микроархитектуру и уникальный набор инструкций, который оно реализует.** Это приводит к уникальной, если не структуре, то конфигурации верификационного окружения.

### Так упрощает или усложняет?

**Для RISC-V ситуация в итоге выглядит неоднозначно.** С одной стороны, инженер имеет доступ к большому количеству открытых решений, с другой стороны, ни одно из них не подходит ему в полной мере.

Верификация сводится в итоге к интеграции, модификации и настройке уже существующих сценариев тестирования, а также самостоятельному описанию части, взаимодействующей с микроархитектурными элементами.

## To be continued...

В данном занятии была заложена база, позволяющая понять основные подходы, используемые в верификации процессорных ядер, которые будут разобраны в [следующем занятии](./02_approach.md). Поговорим о том, что такое формальная верификация и верификация на основе симуляции, и как они применяются для тестирования RISC-V ядер.

[^1]: Быстрое преобразование Фурье - алгоритм ускоренного вычисления дискретного преобразования Фурье. [Прекрасное видео про математический аппарат преобразования Фурье](https://www.youtube.com/watch?v=spUNpyF58BY).

[^2]: Термин "инженер-проектировщик" или "проектировщик" в данном контексте аналогичен английскому термину "Design Engineer".

[^3]: HDL-описание - представление цифрового устройства в виде кода языков описания аппаратуры (Hardware Description Language, HDL). Примеры таких языков: Verilog, SystemVerilog, VHDL. [Лекция Школы синтеза цифровых схем на эту тему](https://youtu.be/DFcvEO-gP0c?t=1310).

[^4]: RTL-описание - представление цифрового устройства в виде описания [логических операций](https://en.wikipedia.org/wiki/Boolean_algebra), которые применяются к данным, которые распространяются между [регистрами](https://en.wikipedia.org/wiki/Hardware_register).

[^5]: Под термином "дизайн" подразумевается некоторое представление цифрового устройство. Как правило, этим термином начинают оперировать на этапе RTL и заканчивают на этапах физического дизайна и его верификции (вместо термина "физический дизайн" начинают употреблять термин "чип"/"микросхема" и т.п.).

[^6]: Оговорка: для создания простейшего ядра в случае RISC-V достаточно ознакомиться всего с несколькими десятками страниц спецификации. Но только для простейшего. О конкурентоспособности речи не идет.

[^7]: Соглашение о вызовах - документ, регламентирующий, как подпрограммы получают аргументы от вызывающей их программы, и как они возвращают результат. Работа над соглашением о вызовых RISC-V ведется в [этом документе](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc).

[^8]: С отладкой в индустрии все обстоит достаточно интересно. Работа над спецификацией на нее все еще активно ведется ([ссылка репозиторий](https://github.com/riscv/riscv-debug-spec)), однако необходимость в рабочем решении появилась еще давно. Это привело к тому, что большинство компаний разработали свои [собственные решения](https://www.sifive.com/technology/sifive-insight). Например, в описании флагманских ядер команий [Syntacore](https://syntacore.com/products/scr9) и [SiFive](https://www.sifive.com/cores/performance-p870-p870a) не упоминается о соответствии реализации отладки какой-либо версии ее спецификации.
